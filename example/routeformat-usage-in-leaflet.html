<!DOCTYPE html>
<html>
<head>
    <title>Ariadne Route Format Example</title>
    <meta charset="utf-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- hosted versions of Leaflet & jQuery -->
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
    
    <style>
        body {
            padding: 0;
            margin: 0;
        }
        html, body, #map {
            height: 100%;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <script>
        var map = L.map('map').setView([48.2484, 16.3854], 14);

        var osmUrl='http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        var osmAttrib='Map data Â© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';
        L.tileLayer(osmUrl, {minZoom: 8, maxZoom: 18, attribution: osmAttrib}).addTo(map);
        
        /** 
        expects: a feature (linestring) with properties
        returns: a style for the feature depending on the properties
        */
        function styleGeoJson(feature) {
            if (typeof feature.properties !== 'undefined') {
                return feature.properties;
            }
        }
        
        $.getJSON("routeformat-example.json", function(json) {
            
            L.geoJson(json.request.from.position, {
            }).addTo(map);
            L.geoJson(json.request.to.position, {
            }).addTo(map);
            
            for(var routeId = 0; routeId < json.routes.length; routeId++) {
                for(var segmentId = 0; segmentId < json.routes[routeId].segments.length; segmentId++) {
                    if (typeof json.routes[routeId].segments[segmentId].geometryGeoJson !== 'undefined') {
                        fullRoute = json.routes[routeId].segments[segmentId].geometryGeoJson;
                        console.log(fullRoute);
                        L.geoJson(fullRoute, {
                            style: function (feature) {
                                return styleGeoJson(feature);
                            }
                        }).addTo(map);
                    } else {
                        console.log("no geometryGeoJson available for route with index " + routeId);
                    }
                }
            }

            for(var routeId = 0; routeId < json.routes.length; routeId++) {
                for(var segmentId = 0; segmentId < json.routes[routeId].segments.length; segmentId++) {
                    if (typeof json.routes[routeId].segments[segmentId].geometryGeoJsonEdges !== 'undefined') {
                        edges = json.routes[routeId].segments[segmentId].geometryGeoJsonEdges;
                        console.log(edges);
                        L.geoJson(edges, {
                            style: function (feature) {
                                return {weight: feature.properties.edgeWeight/5, opacity: 0.3, color:"#f00"};
                            }
                        }).addTo(map);
                    } else {
                        console.log("no geometryGeoJsonEdges available for route with index " + routeId);
                    }
                }
            }
        });
    </script>
</body>
</html>